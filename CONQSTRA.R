# A lexical scanner generated by lex.
#
# ver  date   who remarks
# ---  ----   --- -------------------------------------------------------
# 02a 20aug84  vp .rewritten

include "lskdef"

define(YYDEFAULTACTION,call error( "lex scanner jammed" ))
 # yaccskel - LR parser skeleton
 # ver  date   who remarks
 # --- ------- --- -----------------------------------------------------
 # 05a 17Sep85 cal .Written. Adapted from yyplb.
 #
 # description
 #
 #    A lexical analyzer is required, but is not provided in this set
 #    of routines. A reference is made to the lexical analysis routine,
 #    yylex(), in the routines yyparse() and yyperr(), to indicate where
 #    the call should be made. The scanner routine should read the next
 #    token on the input and return the token number. If there is a value
 #    associated with the token, it should be assigned to the integer
 #    parameter of yylex(). Fancier error correction routines may require
 #    that a queue of tokens be kept. revision of routines yyperr(),
 #    yydotran(), and yyparse() would probably be necessary to handle the
 #    expanded method for handling tokens.
 #
 # XXX REALLY ONLY USE YYENDTOK, YYERROR, AND YYERRTRAN
 include "yypdef"				# various global defines
 # yysstk - state stack
 # yyvstk - value stack
 # yytstk - token stack
 define(YYSCOM,
     integer yysstk(YYMAXSTACK), yyvstk(YYMAXSTACK), yytstk(YYMAXSTACK)
     common /yyscom/ yysstk, yyvstk, yytstk)
 # yyval - token value from yysem
 # yylexval - token value from yylex
 # yytok - token number
 # yyetok - error token
 # yyeval - value of error token
 # yycover - error recovery flag
 # yyerct - recovery error count
 # yysta - current state
 # yystkp - stack pointer
 define(YYPCOM,
     integer yyval, yylexval, yytok, yyetok, yyeval,
	 yycover, yyerct, yysta, yystkp
     common /yypcom/ yyval, yylexval, yytok, yyetok, yyeval,
	 yycover, yyerct, yysta, yystkp)
 define(YYERRACTION,call remark( $1 ))		# default error message code
 define(YYTRACE,)				# optional yylex() trace hook
 define(YYDUMPSTACKS,)				# optional stack dumping hook
 define(TOK_VARIABLE,260)
 define(TOK_OPERATOR,261)
 define(TOK_NUMBER,262)
 define(TOK_TERMINATOR,263)
 define(TOK_ACTION,264)
 define(TOK_AND,265)
 define(TOK_NOT,266)
 define(YYMAXSTACK,25)
### yylex - lexical scanner for conqstrat
#

# Global defines go here.
include "conqdef"

#define(DEBUG,)		# uncomment this to get extra debug code

define(OP_LT,101)
define(OP_LE,102)
define(OP_GT,103)
define(OP_GE,104)
define(OP_EQ,105)
define(OP_NE,106)

define(CONQSTRATCOMMON,
    integer fd, line, rulenum, trstrat(MAX_VAR,10), trvec(32)
    logical goterror, debug, verbose
    character filename(MAXLINE)
    common /conqstratcommon/ fd, line, rulenum, trstrat, trvec,
	goterror, debug, verbose, filename)

define(YYINPUT,
    {line = line + 1
    $3 = getlin( $1($2), fd )})

define(YYDEFAULTACTION,
    {YYGETTEXT( buf )
    call eprintf( "conqstrat: Bad input at line %d, @"%s@"@n", line, buf )
    goterror = .true.})

define(YYERRACTION,call myerrmsg( $1 ))

#define(YYTRACE,call eprintf( " tok %d, (val %d)@n", yytok, yylexval ))

define(RET_VARIABLE,{yyval = $1; return( TOK_VARIABLE )})
define(RET_ACTION,{yyval = $1; return( TOK_ACTION )})
define(RET_OPERATOR,{yyval = $1; return( TOK_OPERATOR )})
YYDECL
define(YYLEX_SC_0,1)


    NOIMPLICIT
    character buf(MAXLINE)
    integer i, ctoi
    CONQSTRATCOMMON

    yyval = 0


    integer yycbufp, yybbufp, yyebufp, yystbuf(YYBUFSIZE), yycurst, yystart
    integer yybufpos, yynchars, yyiii, yyjjj, yylp, getlin, yyisym, yyjam
    integer yytmp, yystat
    character yychbuf(YYBUFSIZE), yysym
    logical yyinit, yysaweof

    data yyinit /.true./

    if ( yyinit )
	{
	YYINIT
	yystart = 1
	yyinit = .false.
	}

    repeat # until an action does a return
	{
	# set up to begin running DFA

	yycurst = yystart

	if ( yychbuf(yycbufp) == '@n' )
	    yycurst = yycurst + 1

ifdef(LEX_MONDO_DEBUG)
	call fprintf( ERROUT, "Beginning in state %d@nInput:  ", yycurst )
enddef

	# yybbufp really points to the position in yychbuf *before* the
	# start of the current run.  If it actually pointed to the start
	# position in yychbuf, we'd have to subtract one from it several
	# times down the line.

	yybbufp = yycbufp

	repeat # until the machine jams
	    {
	    if ( yycbufp == yyebufp )
		{ # need more input
		if ( yyebufp > YYBUFLIM )
		    { # not enough room to do another read
		    # see if we can make some room for more chars

		    yynchars = yyebufp - yybbufp

		    if ( yynchars > 0 )
			# shift down buffer to make room
			do yyiii = 1, yynchars
			    {
			    yybufpos = yybbufp + yyiii
			    yychbuf(yyiii) = yychbuf(yybufpos)
			    yystbuf(yyiii) = yystbuf(yybufpos)
			    }

		    yybbufp = 0
		    yyebufp = yynchars

		    if ( yyebufp > YYBUFLIM )
			call error( "lex input buffer overflowed" )

		    yycbufp = yyebufp
		    }

		else if ( yysaweof )
		    {
1		    if ( yybbufp == yyebufp )
			{
			YYWRAP(yystat)
			if ( yystat != 0 )
			    {
			    YYEOFACTION
			    }
			
			else
			    {
			    YYINIT
			    next 2  # to top of outermost repeat loop
			    }
			}

		    else # do a jam to eat up more input
			break
		    }

		YYINPUT( yychbuf, yycbufp + 1, yynchars )

		if ( yynchars == EOF )
		    {
		    if ( yysaweof )
			call error( "lex scanner saw EOF twice - _
				     shouldn't happen" )
		    yysaweof = .true.
		    goto 1
		    }

		yyebufp = yyebufp + yynchars
		}

	    yycbufp = yycbufp + 1

ifdef(LEX_MONDO_DEBUG)
	    call fprintf( ERROUT, "%c", yychbuf(yycbufp) )
enddef

	    yysym = e(yychbuf(yycbufp))

ifdef(LEX_MONDO_DEBUG)
	    yyisym = yysym
	    call fprintf( ERROUT, "(%d) ", yyisym )
enddef

	    while ( c(b(yycurst) + yysym) != yycurst )
		{
		yycurst = d(yycurst)

		# we've arrange it so that templates are never chained
		# to one another.  This means we can afford make a very
		# simple test to see if we need to convert to yysym's
		# meta-equivalence class without worrying about erroneously
		# looking up the meta-equivalence class twice

		if ( yycurst >= yytmp )
		    yysym = m(yysym)
		}

	    yycurst = n(b(yycurst) + yysym)
	    yystbuf(yycbufp) = yycurst

ifdef(LEX_MONDO_DEBUG)
	    call fprintf( ERROUT, "@nEntering state #%d@n", yycurst )
enddef
	    }
	until ( b(yycurst) == yyjam )

	repeat # until we find what rule we matched
	    {
	    yylp = l(yystbuf(yycbufp))

	    if ( yylp < l(yystbuf(yycbufp) + 1) )
		{
ifdef(LEX_DEBUG)
		call fprintf( ERROUT, "--accepting rule #%d@n", a(yylp) )
enddef
		switch ( a(yylp) )
		    {
case 1:
RET_VARIABLE( VAR_RANDOM )
case 2:
RET_VARIABLE( VAR_DNE )
case 3:
RET_VARIABLE( VAR_DAMAGE )
case 4:
RET_VARIABLE( VAR_INCOMING )
case 5:
RET_VARIABLE( VAR_FUEL )
case 6:
RET_VARIABLE( VAR_NUMTORPS )
case 7:
RET_VARIABLE( VAR_SHIELDS )
case 8:
RET_VARIABLE( VAR_ETEMP )
case 9:
RET_VARIABLE( VAR_WTEMP )
case 10:
RET_VARIABLE( VAR_PHASERDAM )
case 11:
RET_VARIABLE( VAR_TORPDAM )
case 12:
RET_VARIABLE( VAR_WARP )
case 13:
RET_VARIABLE( VAR_SHUP )
case 14:
RET_VARIABLE( VAR_WALLOC )
case 15:
RET_VARIABLE( VAR_ORBITING )
case 16:
RET_VARIABLE( VAR_REPAIRING )
case 17:
RET_VARIABLE( VAR_CLOAKED )
case 18:
RET_VARIABLE( VAR_ENEMYCLOAKED )
case 19:
RET_VARIABLE( VAR_ENEMYDAMAGE )
case 20:
RET_VARIABLE( VAR_CANREAD )
case 21:
RET_ACTION( ROB_NOOP )
case 22:
RET_ACTION( ROB_GOHOME )
case 23:
RET_ACTION( ROB_GOREPAIR )
case 24:
RET_ACTION( ROB_ALLOCATE )
case 25:
RET_ACTION( ROB_DETONATE )
case 26:
RET_ACTION( ROB_MYDETONATE )
case 27:
RET_ACTION( ROB_PHASER )
case 28:
RET_ACTION( ROB_TORPEDO )
case 29:
RET_ACTION( ROB_BURST )
case 30:
RET_ACTION( ROB_SHIELD )
case 31:
RET_ACTION( ROB_UNTRACTOR )
case 32:
RET_ACTION( ROB_WARP_0 )
case 33:
RET_ACTION( ROB_WARP_2 )
case 34:
RET_ACTION( ROB_WARP_5 )
case 35:
RET_ACTION( ROB_WARP_8 )
case 36:
RET_ACTION( ROB_TRACK )
case 37:
RET_ACTION( ROB_SLIENT )
case 38:
RET_ACTION( ROB_MESSAGE )
case 39:
RET_ACTION( ROB_TAKEDRUGS )
case 40:
RET_ACTION( ROB_REPAIR )
case 41:
RET_ACTION( ROB_READMSG )
case 42:
RET_ACTION( ROB_INSULT )
case 43:
RET_ACTION( ROB_GOFUEL )
case 44:
RET_ACTION( ROB_RUNAWAY )
case 45:
RET_OPERATOR( OP_LT )
case 46:
RET_OPERATOR( OP_LE )
case 47:
RET_OPERATOR( OP_GT )
case 48:
RET_OPERATOR( OP_GE )
case 49:
RET_OPERATOR( OP_EQ )
case 50:
RET_OPERATOR( OP_NE )
case 51:
return( TOK_NOT )
case 52:
return( TOK_AND )
case 53:
return( TOK_TERMINATOR )
case 54:

			YYGETTEXT( buf )
			i = 1
			yyval = ctoi( buf, i )
			return( TOK_NUMBER )

case 55:
# eat comments
case 56:
# eat gratuitous white space
case 57:
# eat newlines
%      data l(1)/1/,l(2)/1/,l(3)/1/,a(1)/56/,l(4)/2/,a(2)/57/,l(5)/3/
%      data a(3)/51/,l(6)/4/,a(4)/55/,l(7)/5/,a(5)/52/,l(8)/6/,a(6)/54/
%      data l(9)/7/,a(7)/53/,l(10)/8/,a(8)/45/,l(11)/9/,a(9)/49/
%      data l(12)/10/,a(10)/47/,l(13)/11/,l(14)/11/,l(15)/11/,l(16)/11/
%      data l(17)/11/,l(18)/11/,l(19)/11/,l(20)/11/,l(21)/11/,l(22)/11/
%      data l(23)/11/,l(24)/11/,l(25)/11/,a(11)/50/,l(26)/12/,a(12)/55/
%      data l(27)/13/,a(13)/46/,l(28)/14/,a(14)/49/,l(29)/15/,a(15)/48/
%      data l(30)/16/,l(31)/16/,l(32)/16/,l(33)/16/,l(34)/16/,l(35)/16/
%      data l(36)/16/,l(37)/16/,l(38)/16/,l(39)/16/,l(40)/16/,l(41)/16/
%      data l(42)/16/,l(43)/16/,l(44)/16/,l(45)/16/,l(46)/16/,l(47)/16/
%      data l(48)/16/,l(49)/16/,l(50)/16/,l(51)/16/,a(16)/2/,l(52)/17/
%      data l(53)/17/,l(54)/17/,l(55)/17/,l(56)/17/,l(57)/17/,l(58)/17/
%      data l(59)/17/,l(60)/17/,l(61)/17/,l(62)/17/,l(63)/17/,l(64)/17/
%      data l(65)/17/,l(66)/17/,l(67)/17/,l(68)/17/,l(69)/17/,l(70)/17/
%      data l(71)/17/,l(72)/17/,l(73)/17/,a(17)/5/,l(74)/18/,l(75)/18/
%      data l(76)/18/,l(77)/18/,l(78)/18/,l(79)/18/,l(80)/18/,l(81)/18/
%      data l(82)/18/,a(18)/13/,l(83)/19/,l(84)/19/,l(85)/19/,a(19)/12/
%      data l(86)/20/,l(87)/20/,l(88)/20/,l(89)/20/,l(90)/20/,l(91)/20/
%      data a(20)/8/,l(92)/21/,l(93)/21/,l(94)/21/,l(95)/21/,l(96)/21/
%      data l(97)/21/,l(98)/21/,l(99)/21/,l(100)/21/,l(101)/21/
%      data l(102)/21/,l(103)/21/,l(104)/21/,l(105)/21/,l(106)/21/
%      data l(107)/21/,l(108)/21/,l(109)/21/,l(110)/21/,l(111)/21/
%      data l(112)/21/,l(113)/21/,l(114)/21/,a(21)/9/,l(115)/22/
%      data l(116)/22/,l(117)/22/,a(22)/3/,l(118)/23/,l(119)/23/
%      data l(120)/23/,l(121)/23/,l(122)/23/,l(123)/23/,l(124)/23/
%      data a(23)/1/,l(125)/24/,l(126)/24/,l(127)/24/,l(128)/24/
%      data l(129)/24/,l(130)/24/,l(131)/24/,l(132)/24/,l(133)/24/
%      data l(134)/24/,l(135)/24/,l(136)/24/,l(137)/24/,l(138)/24/
%      data l(139)/24/,l(140)/24/,l(141)/24/,l(142)/24/,l(143)/24/
%      data l(144)/24/,l(145)/24/,l(146)/24/,a(24)/14/,l(147)/25/
%      data a(25)/20/,l(148)/26/,a(26)/17/,l(149)/27/,l(150)/27/
%      data l(151)/27/,l(152)/27/,l(153)/27/,l(154)/27/,l(155)/27/
%      data l(156)/27/,l(157)/27/,l(158)/27/,l(159)/27/,l(160)/27/
%      data l(161)/27/,l(162)/27/,l(163)/27/,l(164)/27/,l(165)/27/
%      data l(166)/27/,l(167)/27/,l(168)/27/,l(169)/27/,l(170)/27/
%      data l(171)/27/,l(172)/27/,l(173)/27/,l(174)/27/,l(175)/27/
%      data l(176)/27/,l(177)/27/,a(27)/7/,l(178)/28/,a(28)/11/
%      data l(179)/29/,l(180)/29/,l(181)/29/,a(29)/4/,l(182)/30/
%      data a(30)/6/,l(183)/31/,a(31)/15/,l(184)/32/,l(185)/32/
%      data l(186)/32/,l(187)/32/,l(188)/32/,l(189)/32/,l(190)/32/
%      data l(191)/32/,l(192)/32/,l(193)/32/,l(194)/32/,l(195)/32/
%      data a(32)/21/,l(196)/33/,l(197)/33/,l(198)/33/,l(199)/33/
%      data l(200)/33/,l(201)/33/,l(202)/33/,l(203)/33/,l(204)/33/
%      data l(205)/33/,l(206)/33/,l(207)/33/,l(208)/33/,l(209)/33/
%      data a(33)/10/,l(210)/34/,a(34)/16/,l(211)/35/,l(212)/35/
%      data a(35)/29/,l(213)/36/,l(214)/36/,l(215)/36/,l(216)/36/
%      data l(217)/36/,l(218)/36/,l(219)/36/,l(220)/36/,l(221)/36/
%      data l(222)/36/,l(223)/36/,l(224)/36/,l(225)/36/,l(226)/36/
%      data l(227)/36/,l(228)/36/,a(36)/36/,l(229)/37/,l(230)/37/
%      data l(231)/37/,l(232)/37/,l(233)/37/,l(234)/37/,l(235)/37/
%      data a(37)/43/,l(236)/38/,a(38)/22/,l(237)/39/,l(238)/39/
%      data a(39)/42/,l(239)/40/,l(240)/40/,l(241)/40/,a(40)/27/
%      data l(242)/41/,l(243)/41/,a(41)/40/,l(244)/42/,l(245)/42/
%      data a(42)/30/,l(246)/43/,a(43)/37/,l(247)/44/,l(248)/44/
%      data l(249)/44/,l(250)/44/,a(44)/32/,l(251)/45/,a(45)/33/
%      data l(252)/46/,a(46)/34/,l(253)/47/,a(47)/35/,l(254)/48/
%      data l(255)/48/,a(48)/19/,l(256)/49/,l(257)/49/,l(258)/49/
%      data l(259)/49/,a(49)/38/,l(260)/50/,l(261)/50/,a(50)/41/
%      data l(262)/51/,a(51)/44/,l(263)/52/,l(264)/52/,a(52)/28/
%      data l(265)/53/,l(266)/53/,a(53)/18/,l(267)/54/,a(54)/24/
%      data l(268)/55/,a(55)/25/,l(269)/56/,a(56)/23/,l(270)/57/
%      data l(271)/57/,l(272)/57/,l(273)/57/,l(274)/57/,a(57)/39/
%      data l(275)/58/,a(58)/31/,l(276)/59/,a(59)/26/,l(277)/60/
%      data l(278)/60/
		    }
		next 2  # to top of outermost repeat loop
		}

	    yycbufp = yycbufp - 1
	    }
	until ( yycbufp == yybbufp )

	# if we got this far, then we didn't find any accepting states

	yycbufp = yycbufp + 1  # so the default applies to the first char read

	YYDEFAULTACTION
	}

integer l(278)
integer a(59)
integer e(127)
integer m(37)
integer b(278)
integer d(278)
integer n(318)
integer c(318)
%      data yyjam/281/
%      data yytmp/278/
%      data e(1)/1/,e(2)/1/,e(3)/1/,e(4)/1/,e(5)/1/,e(6)/1/,e(7)/1/
%      data e(8)/1/,e(9)/2/,e(10)/3/,e(11)/1/,e(12)/1/,e(13)/1/,e(14)/1/
%      data e(15)/1/,e(16)/1/,e(17)/1/,e(18)/1/,e(19)/1/,e(20)/1/
%      data e(21)/1/,e(22)/1/,e(23)/1/,e(24)/1/,e(25)/1/,e(26)/1/
%      data e(27)/1/,e(28)/1/,e(29)/1/,e(30)/1/,e(31)/1/,e(32)/2/
%      data e(33)/4/,e(34)/1/,e(35)/5/,e(36)/1/,e(37)/1/,e(38)/6/
%      data e(39)/1/,e(40)/1/,e(41)/1/,e(42)/1/,e(43)/1/,e(44)/1/
%      data e(45)/1/,e(46)/1/,e(47)/1/,e(48)/7/,e(49)/8/,e(50)/9/
%      data e(51)/8/,e(52)/8/,e(53)/10/,e(54)/8/,e(55)/8/,e(56)/11/
%      data e(57)/8/,e(58)/1/,e(59)/12/,e(60)/13/,e(61)/14/,e(62)/15/
%      data e(63)/1/,e(64)/1/,e(65)/17/,e(66)/18/,e(67)/19/,e(68)/20/
%      data e(69)/21/,e(70)/22/,e(71)/23/,e(72)/24/,e(73)/25/,e(74)/1/
%      data e(75)/26/,e(76)/27/,e(77)/28/,e(78)/29/,e(79)/30/,e(80)/31/
%      data e(81)/1/,e(82)/32/,e(83)/33/,e(84)/34/,e(85)/35/,e(86)/1/
%      data e(87)/36/,e(88)/1/,e(89)/37/,e(90)/1/,e(91)/1/,e(92)/1/
%      data e(93)/1/,e(94)/1/,e(95)/16/,e(96)/1/,e(97)/17/,e(98)/18/
%      data e(99)/19/,e(100)/20/,e(101)/21/,e(102)/22/,e(103)/23/
%      data e(104)/24/,e(105)/25/,e(106)/1/,e(107)/26/,e(108)/27/
%      data e(109)/28/,e(110)/29/,e(111)/30/,e(112)/31/,e(113)/1/
%      data e(114)/32/,e(115)/33/,e(116)/34/,e(117)/35/,e(118)/1/
%      data e(119)/36/,e(120)/1/,e(121)/37/,e(122)/1/,e(123)/1/
%      data e(124)/1/,e(125)/1/,e(126)/1/,e(127)/1/
%      data m(1)/1/,m(2)/1/,m(3)/2/,m(4)/1/,m(5)/1/,m(6)/1/,m(7)/1/
%      data m(8)/1/,m(9)/1/,m(10)/1/,m(11)/1/,m(12)/1/,m(13)/1/,m(14)/1/
%      data m(15)/1/,m(16)/1/,m(17)/1/,m(18)/1/,m(19)/1/,m(20)/1/
%      data m(21)/1/,m(22)/1/,m(23)/1/,m(24)/1/,m(25)/1/,m(26)/1/
%      data m(27)/1/,m(28)/1/,m(29)/1/,m(30)/1/,m(31)/1/,m(32)/1/
%      data m(33)/1/,m(34)/1/,m(35)/1/,m(36)/1/,m(37)/1/
%      data b(1)/0/,d(1)/277/,b(2)/0/,d(2)/1/,b(3)/279/,d(3)/277/
%      data b(4)/281/,d(4)/277/,b(5)/266/,d(5)/277/,b(6)/0/,d(6)/278/
%      data b(7)/281/,d(7)/277/,b(8)/281/,d(8)/277/,b(9)/281/,d(9)/277/
%      data b(10)/2/,d(10)/277/,b(11)/265/,d(11)/277/,b(12)/264/
%      data d(12)/277/,b(13)/1/,d(13)/277/,b(14)/6/,d(14)/277/,b(15)/8/
%      data d(15)/277/,b(16)/242/,d(16)/277/,b(17)/247/,d(17)/277/
%      data b(18)/240/,d(18)/277/,b(19)/242/,d(19)/277/,b(20)/249/
%      data d(20)/277/,b(21)/22/,d(21)/277/,b(22)/248/,d(22)/277/
%      data b(23)/241/,d(23)/277/,b(24)/7/,d(24)/277/,b(25)/281/
%      data d(25)/277/,b(26)/0/,d(26)/278/,b(27)/281/,d(27)/277/
%      data b(28)/281/,d(28)/277/,b(29)/281/,d(29)/277/,b(30)/241/
%      data d(30)/277/,b(31)/239/,d(31)/277/,b(32)/240/,d(32)/277/
%      data b(33)/246/,d(33)/277/,b(34)/245/,d(34)/277/,b(35)/244/
%      data d(35)/277/,b(36)/243/,d(36)/277/,b(37)/244/,d(37)/277/
%      data b(38)/234/,d(38)/277/,b(39)/243/,d(39)/277/,b(40)/243/
%      data d(40)/277/,b(41)/230/,d(41)/277/,b(42)/227/,d(42)/277/
%      data b(43)/239/,d(43)/277/,b(44)/13/,d(44)/277/,b(45)/224/
%      data d(45)/277/,b(46)/13/,d(46)/277/,b(47)/234/,d(47)/277/
%      data b(48)/222/,d(48)/277/,b(49)/236/,d(49)/277/,b(50)/235/
%      data d(50)/277/,b(51)/281/,d(51)/277/,b(52)/223/,d(52)/277/
%      data b(53)/222/,d(53)/277/,b(54)/222/,d(54)/277/,b(55)/218/
%      data d(55)/277/,b(56)/213/,d(56)/277/,b(57)/221/,d(57)/277/
%      data b(58)/212/,d(58)/277/,b(59)/224/,d(59)/277/,b(60)/226/
%      data d(60)/277/,b(61)/226/,d(61)/277/,b(62)/220/,d(62)/277/
%      data b(63)/209/,d(63)/277/,b(64)/208/,d(64)/277/,b(65)/211/
%      data d(65)/277/,b(66)/206/,d(66)/277/,b(67)/208/,d(67)/277/
%      data b(68)/214/,d(68)/277/,b(69)/208/,d(69)/277/,b(70)/210/
%      data d(70)/277/,b(71)/195/,d(71)/277/,b(72)/200/,d(72)/277/
%      data b(73)/281/,d(73)/277/,b(74)/202/,d(74)/277/,b(75)/199/
%      data d(75)/277/,b(76)/194/,d(76)/277/,b(77)/206/,d(77)/277/
%      data b(78)/196/,d(78)/277/,b(79)/200/,d(79)/277/,b(80)/36/
%      data d(80)/277/,b(81)/197/,d(81)/277/,b(82)/281/,d(82)/277/
%      data b(83)/203/,d(83)/277/,b(84)/192/,d(84)/277/,b(85)/281/
%      data d(85)/277/,b(86)/190/,d(86)/277/,b(87)/203/,d(87)/277/
%      data b(88)/198/,d(88)/277/,b(89)/197/,d(89)/277/,b(90)/7/
%      data d(90)/277/,b(91)/281/,d(91)/277/,b(92)/192/,d(92)/277/
%      data b(93)/184/,d(93)/277/,b(94)/190/,d(94)/277/,b(95)/182/
%      data d(95)/277/,b(96)/185/,d(96)/277/,b(97)/180/,d(97)/277/
%      data b(98)/184/,d(98)/277/,b(99)/175/,d(99)/277/,b(100)/188/
%      data d(100)/277/,b(101)/178/,d(101)/277/,b(102)/178/,d(102)/277/
%      data b(103)/23/,d(103)/277/,b(104)/176/,d(104)/277/,b(105)/181/
%      data d(105)/277/,b(106)/28/,d(106)/277/,b(107)/23/,d(107)/277/
%      data b(108)/45/,d(108)/277/,b(109)/175/,d(109)/277/,b(110)/186/
%      data d(110)/277/,b(111)/182/,d(111)/277/,b(112)/184/,d(112)/277/
%      data b(113)/181/,d(113)/277/,b(114)/281/,d(114)/277/,b(115)/179/
%      data d(115)/277/,b(116)/178/,d(116)/277/,b(117)/281/,d(117)/277/
%      data b(118)/170/,d(118)/277/,b(119)/179/,d(119)/277/,b(120)/166/
%      data d(120)/277/,b(121)/163/,d(121)/277/,b(122)/164/,d(122)/277/
%      data b(123)/172/,d(123)/277/,b(124)/281/,d(124)/277/,b(125)/166/
%      data d(125)/277/,b(126)/163/,d(126)/277/,b(127)/157/,d(127)/277/
%      data b(128)/154/,d(128)/277/,b(129)/52/,d(129)/277/,b(130)/154/
%      data d(130)/277/,b(131)/153/,d(131)/277/,b(132)/165/,d(132)/277/
%      data b(133)/154/,d(133)/277/,b(134)/166/,d(134)/277/,b(135)/49/
%      data d(135)/277/,b(136)/153/,d(136)/277/,b(137)/156/,d(137)/277/
%      data b(138)/155/,d(138)/277/,b(139)/153/,d(139)/277/,b(140)/146/
%      data d(140)/277/,b(141)/160/,d(141)/277/,b(142)/142/,d(142)/277/
%      data b(143)/143/,d(143)/277/,b(144)/141/,d(144)/277/,b(145)/145/
%      data d(145)/277/,b(146)/281/,d(146)/277/,b(147)/281/,d(147)/277/
%      data b(148)/281/,d(148)/277/,b(149)/142/,d(149)/277/,b(150)/143/
%      data d(150)/277/,b(151)/147/,d(151)/277/,b(152)/136/,d(152)/277/
%      data b(153)/145/,d(153)/277/,b(154)/150/,d(154)/277/,b(155)/137/
%      data d(155)/277/,b(156)/135/,d(156)/277/,b(157)/131/,d(157)/277/
%      data b(158)/133/,d(158)/277/,b(159)/127/,d(159)/277/,b(160)/131/
%      data d(160)/277/,b(161)/139/,d(161)/277/,b(162)/124/,d(162)/277/
%      data b(163)/125/,d(163)/277/,b(164)/136/,d(164)/277/,b(165)/125/
%      data d(165)/277/,b(166)/122/,d(166)/277/,b(167)/134/,d(167)/277/
%      data b(168)/136/,d(168)/277/,b(169)/135/,d(169)/277/,b(170)/130/
%      data d(170)/277/,b(171)/129/,d(171)/277/,b(172)/128/,d(172)/277/
%      data b(173)/117/,d(173)/277/,b(174)/128/,d(174)/277/,b(175)/114/
%      data d(175)/277/,b(176)/114/,d(176)/277/,b(177)/281/,d(177)/277/
%      data b(178)/281/,d(178)/277/,b(179)/127/,d(179)/277/,b(180)/126/
%      data d(180)/277/,b(181)/281/,d(181)/277/,b(182)/281/,d(182)/277/
%      data b(183)/281/,d(183)/277/,b(184)/114/,d(184)/277/,b(185)/118/
%      data d(185)/277/,b(186)/121/,d(186)/277/,b(187)/105/,d(187)/277/
%      data b(188)/109/,d(188)/277/,b(189)/116/,d(189)/277/,b(190)/108/
%      data d(190)/277/,b(191)/104/,d(191)/277/,b(192)/107/,d(192)/277/
%      data b(193)/116/,d(193)/277/,b(194)/98/,d(194)/277/,b(195)/281/
%      data d(195)/277/,b(196)/110/,d(196)/277/,b(197)/102/,d(197)/277/
%      data b(198)/104/,d(198)/277/,b(199)/92/,d(199)/277/,b(200)/100/
%      data d(200)/277/,b(201)/97/,d(201)/277/,b(202)/105/,d(202)/277/
%      data b(203)/103/,d(203)/277/,b(204)/97/,d(204)/277/,b(205)/105/
%      data d(205)/277/,b(206)/105/,d(206)/277/,b(207)/94/,d(207)/277/
%      data b(208)/96/,d(208)/277/,b(209)/281/,d(209)/277/,b(210)/281/
%      data d(210)/277/,b(211)/101/,d(211)/277/,b(212)/281/,d(212)/277/
%      data b(213)/100/,d(213)/277/,b(214)/89/,d(214)/277/,b(215)/94/
%      data d(215)/277/,b(216)/97/,d(216)/277/,b(217)/79/,d(217)/277/
%      data b(218)/89/,d(218)/277/,b(219)/81/,d(219)/277/,b(220)/78/
%      data d(220)/277/,b(221)/76/,d(221)/277/,b(222)/76/,d(222)/277/
%      data b(223)/90/,d(223)/277/,b(224)/86/,d(224)/277/,b(225)/71/
%      data d(225)/277/,b(226)/72/,d(226)/277/,b(227)/83/,d(227)/277/
%      data b(228)/281/,d(228)/277/,b(229)/83/,d(229)/277/,b(230)/72/
%      data d(230)/277/,b(231)/80/,d(231)/277/,b(232)/79/,d(232)/277/
%      data b(233)/65/,d(233)/277/,b(234)/64/,d(234)/277/,b(235)/281/
%      data d(235)/277/,b(236)/281/,d(236)/277/,b(237)/72/,d(237)/277/
%      data b(238)/281/,d(238)/277/,b(239)/75/,d(239)/277/,b(240)/66/
%      data d(240)/277/,b(241)/281/,d(241)/277/,b(242)/71/,d(242)/277/
%      data b(243)/281/,d(243)/277/,b(244)/56/,d(244)/277/,b(245)/281/
%      data d(245)/277/,b(246)/281/,d(246)/277/,b(247)/57/,d(247)/277/
%      data b(248)/61/,d(248)/277/,b(249)/56/,d(249)/277/,b(250)/281/
%      data d(250)/277/,b(251)/281/,d(251)/277/,b(252)/281/,d(252)/277/
%      data b(253)/281/,d(253)/277/,b(254)/69/,d(254)/277/,b(255)/281/
%      data d(255)/277/,b(256)/67/,d(256)/277/,b(257)/66/,d(257)/277/
%      data b(258)/54/,d(258)/277/,b(259)/281/,d(259)/277/,b(260)/61/
%      data d(260)/277/,b(261)/281/,d(261)/277/,b(262)/281/,d(262)/277/
%      data b(263)/50/,d(263)/277/,b(264)/281/,d(264)/277/,b(265)/28/
%      data d(265)/277/,b(266)/281/,d(266)/277/,b(267)/281/,d(267)/277/
%      data b(268)/281/,d(268)/277/,b(269)/281/,d(269)/277/,b(270)/23/
%      data d(270)/277/,b(271)/22/,d(271)/277/,b(272)/19/,d(272)/277/
%      data b(273)/25/,d(273)/277/,b(274)/281/,d(274)/277/,b(275)/281/
%      data d(275)/277/,b(276)/281/,d(276)/277/,b(277)/281/,d(277)/-1/
%      data b(278)/84/,d(278)/277/
%      data n(1)/1/,c(1)/0/,n(2)/3/,c(2)/1/,n(3)/4/,c(3)/1/,n(4)/5/
%      data c(4)/1/,n(5)/6/,c(5)/1/,n(6)/7/,c(6)/1/,n(7)/8/,c(7)/1/
%      data n(8)/8/,c(8)/1/,n(9)/8/,c(9)/1/,n(10)/8/,c(10)/1/,n(11)/8/
%      data c(11)/1/,n(12)/9/,c(12)/1/,n(13)/10/,c(13)/1/,n(14)/11/
%      data c(14)/1/,n(15)/12/,c(15)/1/,n(16)/27/,c(16)/10/,n(17)/25/
%      data c(17)/10/,n(18)/30/,c(18)/13/,n(19)/13/,c(19)/1/,n(20)/14/
%      data c(20)/1/,n(21)/15/,c(21)/1/,n(22)/16/,c(22)/1/,n(23)/32/
%      data c(23)/14/,n(24)/46/,c(24)/24/,n(25)/17/,c(25)/1/,n(26)/118/
%      data c(26)/90/,n(27)/119/,c(27)/90/,n(28)/31/,c(28)/13/,n(29)/18/
%      data c(29)/1/,n(30)/19/,c(30)/1/,n(31)/20/,c(31)/1/,n(32)/21/
%      data c(32)/1/,n(33)/22/,c(33)/1/,n(34)/23/,c(34)/1/,n(35)/33/
%      data c(35)/14/,n(36)/24/,c(36)/1/,n(37)/34/,c(37)/15/,n(38)/62/
%      data c(38)/44/,n(39)/41/,c(39)/21/,n(40)/65/,c(40)/46/,n(41)/47/
%      data c(41)/24/,n(42)/35/,c(42)/15/,n(43)/42/,c(43)/21/,n(44)/131/
%      data c(44)/103/,n(45)/66/,c(45)/46/,n(46)/276/,c(46)/273/
%      data n(47)/137/,c(47)/107/,n(48)/63/,c(48)/44/,n(49)/135/
%      data c(49)/106/,n(50)/138/,c(50)/107/,n(51)/275/,c(51)/272/
%      data n(52)/43/,c(52)/21/,n(53)/98/,c(53)/80/,n(54)/99/,c(54)/80/
%      data n(55)/274/,c(55)/271/,n(56)/100/,c(56)/80/,n(57)/273/
%      data c(57)/270/,n(58)/272/,c(58)/265/,n(59)/101/,c(59)/80/
%      data n(60)/132/,c(60)/103/,n(61)/102/,c(61)/80/,n(62)/139/
%      data c(62)/108/,n(63)/136/,c(63)/106/,n(64)/103/,c(64)/80/
%      data n(65)/104/,c(65)/80/,n(66)/167/,c(66)/135/,n(67)/105/
%      data c(67)/80/,n(68)/106/,c(68)/80/,n(69)/107/,c(69)/80/
%      data n(70)/108/,c(70)/80/,n(71)/109/,c(71)/80/,n(72)/110/
%      data c(72)/80/,n(73)/271/,c(73)/263/,n(74)/159/,c(74)/129/
%      data n(75)/140/,c(75)/108/,n(76)/160/,c(76)/129/,n(77)/141/
%      data c(77)/108/,n(78)/270/,c(78)/260/,n(79)/250/,c(79)/230/
%      data n(80)/168/,c(80)/135/,n(81)/251/,c(81)/230/,n(82)/252/
%      data c(82)/230/,n(83)/253/,c(83)/230/,n(84)/161/,c(84)/129/
%      data n(85)/26/,c(85)/278/,n(86)/269/,c(86)/258/,n(87)/268/
%      data c(87)/257/,n(88)/267/,c(88)/256/,n(89)/266/,c(89)/254/
%      data n(90)/265/,c(90)/249/,n(91)/264/,c(91)/248/,n(92)/263/
%      data c(92)/247/,n(93)/262/,c(93)/244/,n(94)/261/,c(94)/242/
%      data n(95)/260/,c(95)/240/,n(96)/259/,c(96)/239/,n(97)/258/
%      data c(97)/237/,n(98)/257/,c(98)/234/,n(99)/256/,c(99)/233/
%      data n(100)/255/,c(100)/232/,n(101)/254/,c(101)/231/,n(102)/249/
%      data c(102)/229/,n(103)/248/,c(103)/227/,n(104)/247/,c(104)/226/
%      data n(105)/246/,c(105)/225/,n(106)/245/,c(106)/224/,n(107)/244/
%      data c(107)/223/,n(108)/243/,c(108)/222/,n(109)/242/,c(109)/221/
%      data n(110)/241/,c(110)/220/,n(111)/240/,c(111)/219/,n(112)/239/
%      data c(112)/218/,n(113)/238/,c(113)/217/,n(114)/237/,c(114)/216/
%      data n(115)/236/,c(115)/215/,n(116)/235/,c(116)/214/,n(117)/234/
%      data c(117)/213/,n(118)/233/,c(118)/211/,n(119)/232/,c(119)/208/
%      data n(120)/231/,c(120)/207/,n(121)/230/,c(121)/206/,n(122)/229/
%      data c(122)/205/,n(123)/228/,c(123)/204/,n(124)/227/,c(124)/203/
%      data n(125)/226/,c(125)/202/,n(126)/225/,c(126)/201/,n(127)/224/
%      data c(127)/200/,n(128)/223/,c(128)/199/,n(129)/222/,c(129)/198/
%      data n(130)/221/,c(130)/197/,n(131)/220/,c(131)/196/,n(132)/219/
%      data c(132)/194/,n(133)/218/,c(133)/193/,n(134)/217/,c(134)/192/
%      data n(135)/216/,c(135)/191/,n(136)/215/,c(136)/190/,n(137)/214/
%      data c(137)/189/,n(138)/213/,c(138)/188/,n(139)/212/,c(139)/187/
%      data n(140)/211/,c(140)/186/,n(141)/210/,c(141)/185/,n(142)/209/
%      data c(142)/184/,n(143)/208/,c(143)/180/,n(144)/207/,c(144)/179/
%      data n(145)/206/,c(145)/176/,n(146)/205/,c(146)/175/,n(147)/204/
%      data c(147)/174/,n(148)/203/,c(148)/173/,n(149)/202/,c(149)/172/
%      data n(150)/201/,c(150)/171/,n(151)/200/,c(151)/170/,n(152)/199/
%      data c(152)/169/,n(153)/198/,c(153)/168/,n(154)/197/,c(154)/167/
%      data n(155)/196/,c(155)/166/,n(156)/195/,c(156)/165/,n(157)/194/
%      data c(157)/164/,n(158)/193/,c(158)/163/,n(159)/192/,c(159)/162/
%      data n(160)/191/,c(160)/161/,n(161)/190/,c(161)/160/,n(162)/189/
%      data c(162)/159/,n(163)/188/,c(163)/158/,n(164)/187/,c(164)/157/
%      data n(165)/186/,c(165)/156/,n(166)/185/,c(166)/155/,n(167)/184/
%      data c(167)/154/,n(168)/183/,c(168)/153/,n(169)/182/,c(169)/152/
%      data n(170)/181/,c(170)/151/,n(171)/180/,c(171)/150/,n(172)/179/
%      data c(172)/149/,n(173)/178/,c(173)/145/,n(174)/177/,c(174)/144/
%      data n(175)/176/,c(175)/143/,n(176)/175/,c(176)/142/,n(177)/174/
%      data c(177)/141/,n(178)/173/,c(178)/140/,n(179)/172/,c(179)/139/
%      data n(180)/171/,c(180)/138/,n(181)/170/,c(181)/137/,n(182)/169/
%      data c(182)/136/,n(183)/166/,c(183)/134/,n(184)/165/,c(184)/133/
%      data n(185)/164/,c(185)/132/,n(186)/163/,c(186)/131/,n(187)/162/
%      data c(187)/130/,n(188)/158/,c(188)/128/,n(189)/157/,c(189)/127/
%      data n(190)/156/,c(190)/126/,n(191)/155/,c(191)/125/,n(192)/154/
%      data c(192)/123/,n(193)/153/,c(193)/122/,n(194)/152/,c(194)/121/
%      data n(195)/151/,c(195)/120/,n(196)/150/,c(196)/119/,n(197)/149/
%      data c(197)/118/,n(198)/148/,c(198)/116/,n(199)/147/,c(199)/115/
%      data n(200)/146/,c(200)/113/,n(201)/145/,c(201)/112/,n(202)/144/
%      data c(202)/111/,n(203)/143/,c(203)/110/,n(204)/142/,c(204)/109/
%      data n(205)/134/,c(205)/105/,n(206)/133/,c(206)/104/,n(207)/130/
%      data c(207)/102/,n(208)/129/,c(208)/101/,n(209)/128/,c(209)/100/
%      data n(210)/127/,c(210)/99/,n(211)/126/,c(211)/98/,n(212)/125/
%      data c(212)/97/,n(213)/124/,c(213)/96/,n(214)/123/,c(214)/95/
%      data n(215)/122/,c(215)/94/,n(216)/121/,c(216)/93/,n(217)/120/
%      data c(217)/92/,n(218)/117/,c(218)/89/,n(219)/116/,c(219)/88/
%      data n(220)/115/,c(220)/87/,n(221)/114/,c(221)/86/,n(222)/113/
%      data c(222)/84/,n(223)/112/,c(223)/83/,n(224)/111/,c(224)/81/
%      data n(225)/97/,c(225)/79/,n(226)/96/,c(226)/78/,n(227)/95/
%      data c(227)/77/,n(228)/94/,c(228)/76/,n(229)/93/,c(229)/75/
%      data n(230)/92/,c(230)/74/,n(231)/91/,c(231)/72/,n(232)/90/
%      data c(232)/71/,n(233)/89/,c(233)/70/,n(234)/88/,c(234)/69/
%      data n(235)/87/,c(235)/68/,n(236)/86/,c(236)/67/,n(237)/85/
%      data c(237)/66/,n(238)/84/,c(238)/65/,n(239)/83/,c(239)/64/
%      data n(240)/82/,c(240)/63/,n(241)/81/,c(241)/62/,n(242)/80/
%      data c(242)/61/,n(243)/79/,c(243)/60/,n(244)/78/,c(244)/59/
%      data n(245)/77/,c(245)/58/,n(246)/76/,c(246)/57/,n(247)/75/
%      data c(247)/56/,n(248)/74/,c(248)/55/,n(249)/73/,c(249)/54/
%      data n(250)/72/,c(250)/53/,n(251)/71/,c(251)/52/,n(252)/70/
%      data c(252)/50/,n(253)/69/,c(253)/49/,n(254)/68/,c(254)/48/
%      data n(255)/67/,c(255)/47/,n(256)/64/,c(256)/45/,n(257)/61/
%      data c(257)/43/,n(258)/60/,c(258)/42/,n(259)/59/,c(259)/41/
%      data n(260)/58/,c(260)/40/,n(261)/57/,c(261)/39/,n(262)/56/
%      data c(262)/38/,n(263)/55/,c(263)/37/,n(264)/54/,c(264)/36/
%      data n(265)/53/,c(265)/35/,n(266)/52/,c(266)/34/,n(267)/51/
%      data c(267)/33/,n(268)/50/,c(268)/32/,n(269)/49/,c(269)/31/
%      data n(270)/48/,c(270)/30/,n(271)/45/,c(271)/23/,n(272)/44/
%      data c(272)/22/,n(273)/40/,c(273)/20/,n(274)/39/,c(274)/19/
%      data n(275)/38/,c(275)/18/,n(276)/37/,c(276)/17/,n(277)/36/
%      data c(277)/16/,n(278)/29/,c(278)/12/,n(279)/28/,c(279)/11/
%      data n(280)/25/,c(280)/5/,n(281)/3/,c(281)/3/,n(282)/277/
%      data c(282)/277/,n(283)/277/,c(283)/277/,n(284)/277/,c(284)/277/
%      data n(285)/277/,c(285)/277/,n(286)/277/,c(286)/277/,n(287)/277/
%      data c(287)/277/,n(288)/277/,c(288)/277/,n(289)/277/,c(289)/277/
%      data n(290)/277/,c(290)/277/,n(291)/277/,c(291)/277/,n(292)/277/
%      data c(292)/277/,n(293)/277/,c(293)/277/,n(294)/277/,c(294)/277/
%      data n(295)/277/,c(295)/277/,n(296)/277/,c(296)/277/,n(297)/277/
%      data c(297)/277/,n(298)/277/,c(298)/277/,n(299)/277/,c(299)/277/
%      data n(300)/277/,c(300)/277/,n(301)/277/,c(301)/277/,n(302)/277/
%      data c(302)/277/,n(303)/277/,c(303)/277/,n(304)/277/,c(304)/277/
%      data n(305)/277/,c(305)/277/,n(306)/277/,c(306)/277/,n(307)/277/
%      data c(307)/277/,n(308)/277/,c(308)/277/,n(309)/277/,c(309)/277/
%      data n(310)/277/,c(310)/277/,n(311)/277/,c(311)/277/,n(312)/277/
%      data c(312)/277/,n(313)/277/,c(313)/277/,n(314)/277/,c(314)/277/
%      data n(315)/277/,c(315)/277/,n(316)/277/,c(316)/277/,n(317)/277/
%      data c(317)/277/,n(318)/277/,c(318)/277/

    return # should never get here
end

### conqstrat - main program
#
DRIVER(conqstrat)
NOIMPLICIT

    integer i, getarg, open, yyparse
    character buf(MAXLINE)
    CONQSTRATCOMMON
    string usage "usage: conqstrat [-vd] [file]"

    debug = .false.
    verbose = .false.

    while ( getarg( 1, buf, MAXLINE ) != EOF )
	{
	if ( buf(1) != '-' )
	    break
	for ( i = 2; buf(i) != EOS; i = i + 1 )
	    switch ( buf(i) )
		{
		case 'd', 'D':
		    debug = .true.
		case 'v', 'V':
		    verbose = .true.
		default:
		    call error( usage )
		}
	call delarg( 1 )
	}

    if ( getarg( 1, filename, FILENAMESIZE ) == EOF )
	{
	call strcpy( "<STDIN>", filename )
	fd = STDIN
	}
    else
	{
	call delarg( 1 )
	if ( getarg( 1, buf, MAXLINE ) != EOF )
	    call error( usage )
	fd = open( filename, READ )
	if ( fd == ERR )
	    {
	    call eprintf( "conqstrat: %s - can't open", filename )
	    call error( "" )
	    }
	}

    call initrun

    if ( yyparse( i ) == ERR )
	call error( "conqstrat: yyparse() error" )
    if ( goterror )
	call error( "conqstrat: got error" )

    if ( fd != STDIN )
	call close( fd )

    if ( verbose )
	call displayrun

    call dumprun

DRETURN

end


### initrun - initalize for the run
#
# synopsis
#
#    call initrun
#
subroutine initrun
NOIMPLICIT

    integer i, j
    CONQSTRATCOMMON

    # Initialize random stuff.
    rulenum = 1
    line = 0
    goterror = .false.

    # Initialize the strategy table to accept everything.
    for ( i = 1; i <= MAX_VAR; i = i + 1 )
	for ( j = 1; j <= 10; j = j + 1 )
	    trstrat(i,j) = -1		# set all bits

    # Initialize the rule to action vector to nothing.
    for ( i = 1; i <= 32; i = i + 1 )
	trvec(i) = ROB_NOOP

    return

end


### dumprun - dump the run into the common block
#
# synopsis
#
#    call dumprun
#
subroutine dumprun
NOIMPLICIT

    integer i, j
    CONQSTRATCOMMON
    include "conqcom"

    # This is the only place we include/modify the shared common block.
    if ( commonrev != COMMONSTAMP )
	call error ( "conqstrat: Common block ident mismatch." )

    # Copy the strategy table.
    for ( i = 1; i <= MAX_VAR; i = i + 1 )
	for ( j = 1; j <= 10; j = j + 1 )
	    rstrat(i,j) = trstrat(i,j)

    # Copy the action vector.
    for ( i = 1; i <= 32; i = i + 1 )
	rvec(i) = trvec(i)

    return

end


### displayrun - dump the run to STDOUT
#
# synopsis
#
#    call displayrun
#
subroutine displayrun
NOIMPLICIT

    integer i, j
    character buf(MAXLINE)
    CONQSTRATCOMMON
    string strat "trstrat"
    string vec "trvec"

    call getdandt( buf )
    call printf( "# conqdata - robot strategy data generated on %s@n", buf )
    call printf( "    integer %s(%d,10), %s(32)@n", strat, MAX_VAR, vec )

    call printf( "    data %s /", strat )
    for ( j = 1; j <= 10; j = j + 1 )
	for ( i = 1; i <= MAX_VAR; i = i + 1 )
	    {
	    call printf( "%d", trstrat(i,j) )
	    if ( j < 10 | i < MAX_VAR )
		{
		if ( mod( i, 5 ) == 0 )
		    call puts( ",@n@t" )
		else
		    call putc( ',' )
		}
	    }
    call puts( "/@n" )

    call printf( "    data %s /", vec )
    for ( i = 1; i <= 32; i = i + 1 )
	{
	call printf( "%d", trvec(i) )
	if ( i == 16 )
	    call puts( ",@n@t" )
	else if ( i < 32 )
	    call putc( ',' )
	}
    call puts( "/@n" )

    return

end


### dumprule - dump the current rule
#
# synopsis
#
#    integer action
#    call dumprule( action )
#
subroutine dumprule( action )
NOIMPLICIT
integer action

    integer i, j, tbits
    character buf(MAXLINE)
    CONQSTRATCOMMON

    # Store action.
    trvec(rulenum) = action

    # Check for impossible rules.
    for ( i = 1; i <= MAX_VAR; i = i + 1 )
	{
	# There must be at least one value that this variable accepts.
	tbits = 0
	for ( j = 1; j <= 10; j = j + 1 )
	    tbits = ior( tbits, trstrat(i,j) )
	if ( iand( tbits, ibset( 0, rulenum - 1 ) ) == 0 )
	    {
	    call valstr( i, buf )
	    call eprintf(
		"conqstrat: Rule on line %d can't happen, %s is broken@n",
		line - 1, buf)
	    }
	}

    # Update rule number.
    rulenum = rulenum + 1

    return

end


### addrule - add info to the current rule
#
# synopsis
#
#    integer var, op, num
#    call addrule( var, op, num )
#
subroutine addrule( var, op, num )
NOIMPLICIT
integer var, op, num

    integer i, rulebits
    character svar(32), sop(32)
    CONQSTRATCOMMON

    if ( debug )
	{
	call valstr( var, svar )
	call valstr( op, sop )
	call eprintf( "addrule: var %s, op %s, num %d@n", svar, sop, num )
	}

    if ( rulenum > 32 )
	BAIL( "conqstrat: More than 32 rules; line %d@n", line )
    if ( num < 0 | num > 9 )
	BAIL( "addrule: impossible number %d@n", num )
    if ( var < 1 | num > MAX_VAR )
	BAIL( "addrule: impossible variable %d@n", var )

    rulebits = not( ibset( 0, rulenum - 1 ) )
    switch ( op )
	{
	case OP_LT:
	    for ( i = num; i <= 9; i = i + 1 )
		trstrat(var,i+1) = iand( trstrat(var,i+1), rulebits )
	case OP_LE:
	    for ( i = num + 1; i <= 9; i = i + 1 )
		trstrat(var,i+1) = iand( trstrat(var,i+1), rulebits )
	case OP_GT:
	    for ( i = 0; i <= num; i = i + 1 )
		trstrat(var,i+1) = iand( trstrat(var,i+1), rulebits )
	case OP_GE:
	    for ( i = 0; i < num; i = i + 1 )
		trstrat(var,i+1) = iand( trstrat(var,i+1), rulebits )
	case OP_EQ:
	    for ( i = 0; i <= 9; i = i + 1 )
		if ( i != num )
		    trstrat(var,i+1) = iand( trstrat(var,i+1), rulebits )
	case OP_NE:
	    trstrat(var,num+1) = iand( trstrat(var,num+1), rulebits )
	default:
	    BAIL( "addrule: impossible op %d@n", op )
	}

    return

end


### invertop - invert an operator
#
# synopsis
#
#    integer iop, op, invertop
#    iop = invertop( op )
#
integer function invertop( op )
NOIMPLICIT
integer op

    integer iop

    switch ( op )
	{
	case OP_LT:
	    iop = OP_GE
	case OP_LE:
	    iop = OP_GT
	case OP_GT:
	    iop = OP_LE
	case OP_GE:
	    iop = OP_LT
	default:
	    iop = op
	}

    return ( iop )

end


### valstr - convert a var/op value to a string
#
# synopsis
#
#    integer value
#    character buf()
#    call valstr( value, buf )
#
subroutine valstr( value, buf )
NOIMPLICIT
integer value
character buf(ARB)

    switch ( value )
	{
	case VAR_RANDOM:
	    call strcpy( "random", buf )
	case VAR_DNE:
	    call strcpy( "dne", buf )
	case VAR_DAMAGE:
	    call strcpy( "damage", buf )
	case VAR_INCOMING:
	    call strcpy( "incoming", buf )
	case VAR_FUEL:
	    call strcpy( "fuel", buf )
	case VAR_NUMTORPS:
	    call strcpy( "numtorps", buf )
	case VAR_SHIELDS:
	    call strcpy( "shields", buf )
	case VAR_ETEMP:
	    call strcpy( "etemp", buf )
	case VAR_WTEMP:
	    call strcpy( "wtemp", buf )
	case VAR_PHASERDAM:
	    call strcpy( "phaserdam", buf )
	case VAR_TORPDAM:
	    call strcpy( "torpdam", buf )
	case VAR_WARP:
	    call strcpy( "warp", buf )
	case VAR_SHUP:
	    call strcpy( "shup", buf )
	case VAR_WALLOC:
	    call strcpy( "walloc", buf )
	case VAR_ORBITING:
	    call strcpy( "orbiting", buf )
	case VAR_REPAIRING:
	    call strcpy( "repairing", buf )
	case VAR_CLOAKED:
	    call strcpy( "cloaked", buf )
	case VAR_ENEMYCLOAKED:
	    call strcpy( "enemycloaked", buf )
	case VAR_ENEMYDAMAGE:
	    call strcpy( "enemydamage", buf )
	case VAR_CANREAD:
	    call strcpy( "canread", buf )
	case OP_LT:
	    call strcpy( "lt", buf )
	case OP_LE:
	    call strcpy( "le", buf )
	case OP_GT:
	    call strcpy( "gt", buf )
	case OP_GE:
	    call strcpy( "ge", buf )
	case OP_EQ:
	    call strcpy( "eq", buf )
	case OP_NE:
	    call strcpy( "ne", buf )
	default:
	    call prints( buf, "<%d>", value )
	}

    return

end

### tokstr - convert a token to a string
#
# synopsis
#
#    integer token
#    character buf()
#    call tokstr( token, buf )
#
subroutine tokstr( token, buf )
NOIMPLICIT
integer token
character buf(ARB)

    switch ( token )
	{
	case TOK_VARIABLE:
	    call strcpy( "TOK_VARIABLE", buf )
	case TOK_OPERATOR:
	    call strcpy( "TOK_OPERATOR", buf )
	case TOK_NUMBER:
	    call strcpy( "TOK_NUMBER", buf )
	case TOK_TERMINATOR:
	    call strcpy( "TOK_TERMINATOR", buf )
	case TOK_ACTION:
	    call strcpy( "TOK_ACTION", buf )
	case TOK_AND:
	    call strcpy( "TOK_AND", buf )
	case TOK_NOT:
	    call strcpy( "TOK_NOT", buf )
	case YYENDTOK:
	    call strcpy( "YYENDTOK", buf )
	default:
	    call prints( buf, "TOK_<%d>", token )
	}

    return

end

### myerrmsg - yacc error reporting routine
#
# synopsis
#
#    character buf()
#    call myerrmsg( buf )
#
subroutine myerrmsg( buf )
NOIMPLICIT
character buf(ARB)

    CONQSTRATCOMMON

    call eprintf( "conqstrat: error at line %d: %s@n", line, buf )
    goterror = .true.

end

subroutine yysem( yyprod )
integer yyprod
NOIMPLICIT
integer invertop
character buf(MAXLINE)
CONQSTRATCOMMON
    YYPCOM
    YYSCOM
    switch ( yyprod )
	{

         case          4:
            call dumprule( yyvstk(yystkp-0) )
            

         case          5:
            call dumprule( yyvstk(yystkp-0) )
            

         case          9:
            call addrule( yyvstk(yystkp-2), yyvstk(yystkp-1), yyvstk(yystkp-0) )
            

         case         10:
            call addrule( yyvstk(yystkp-0), invertop( yyvstk(yystkp-1) ), yyvstk(yystkp-2) )
            

         case         11:
            call addrule( yyvstk(yystkp-0), OP_NE, 0 )
            

         case         12:
            call addrule( yyvstk(yystkp-0), OP_EQ, 0 )
            

        default:;
	}

return
end

### yyparse - does the actual parsing of the input
#
# SYNOPSIS
# --------
#    sts = yyparse( retvalue )
#         sts   - ERR if couldn't recover from error, OK otherwise
#         retvalue - value of last production reduced
#
# DESCRIPTION
# -----------
#  This is the actual parsing loop. For the current state, yysta,
#  and the current lookahead, yytok, a shift or tranisition is attempted.
#  If that legal, the shift is performed and the next token is retrieved.
#  If no shift is legal, a reduction is attempted. If no reduction is possible
#  an error has occured and the error recovery routines are called.
#  The error recovery routine may either recover sufficiently to
#  resume a parse at the top of the loop, or will fail and die. A call
#  to yylex, which returns the next token on the input stream,
#  is called only after a successful read transition, as no symbols
#  are read when a reduction is performed. The parse stops successfully
#  on two conditions. First, when the reduction performed is number one,
#  you have reduced to the system goal symbol.  This should normally
#  not occur, though, because you should stop successfully when
#  you transfer to the final state, yyfinal.
#
integer function yyparse( retvalue )
NOIMPLICIT
integer retvalue

    integer prodnum				# production num for reduction
    integer status				# status of parse
    integer leptr				# new stack pointer
    integer yyfdrd				# find possible reduction
    integer yyperr				# error recovery routine
    integer yyfdtr				# find possible transition
    integer state				# new state to transfer to
    integer yylex				# lexical analyzer function
    integer dummy
    string illconerr "Illegal Language Construct."
    string nonasserr "Tried To Associate Non-Associating Operator."
    string ovflerr "Syntactic Stack Overflow"
    YYPCOM					# parse global data
    YYSCOM					# parse state stacks

    integer yyfred(24)
    integer yynset(12)
    integer yylset(4)
    integer yyls(9)
    integer yyprod(12)
    integer yylen(12)
    integer yylhs(12)
    integer yyftrn(24)
    integer yyfinal, yytran(32)
    integer yydbg, yyent(24)
    data yyfinal, yydbg/18,0/

    data yytran(1)/2/,yytran(2)/3/,yytran(3)/4/
    data yytran(4)/5/,yytran(5)/6/,yytran(6)/7/
    data yytran(7)/8/,yytran(8)/9/,yytran(9)/10/
    data yytran(10)/11/,yytran(11)/12/,yytran(12)/13/
    data yytran(13)/14/,yytran(14)/15/,yytran(15)/16/
    data yytran(16)/17/,yytran(17)/3/,yytran(18)/4/
    data yytran(19)/5/,yytran(20)/6/,yytran(21)/18/
    data yytran(22)/7/,yytran(23)/8/,yytran(24)/9/
    data yytran(25)/19/,yytran(26)/20/,yytran(27)/21/
    data yytran(28)/3/,yytran(29)/4/,yytran(30)/6/
    data yytran(31)/22/,yytran(32)/23/
    data yyftrn(1)/1/,yyftrn(2)/2/,yyftrn(3)/11/
    data yyftrn(4)/12/,yyftrn(5)/13/,yyftrn(6)/14/
    data yyftrn(7)/15/,yyftrn(8)/15/,yyftrn(9)/15/
    data yyftrn(10)/17/,yyftrn(11)/17/,yyftrn(12)/26/
    data yyftrn(13)/26/,yyftrn(14)/27/,yyftrn(15)/27/
    data yyftrn(16)/28/,yyftrn(17)/32/,yyftrn(18)/33/
    data yyftrn(19)/33/,yyftrn(20)/33/,yyftrn(21)/33/
    data yyftrn(22)/33/,yyftrn(23)/33/
    data yyftrn(24)/33/
    data yyent(1)/266/,yyent(2)/0/,yyent(3)/266/
    data yyent(4)/262/,yyent(5)/263/,yyent(6)/260/
    data yyent(7)/-1/,yyent(8)/271/,yyent(9)/270/
    data yyent(10)/269/,yyent(11)/268/,yyent(12)/260/
    data yyent(13)/261/,yyent(14)/264/,yyent(15)/261/
    data yyent(16)/265/,yyent(17)/263/,yyent(18)/0/
    data yyent(19)/269/,yyent(20)/260/,yyent(21)/262/
    data yyent(22)/271/,yyent(23)/264/
    data yyent(24)/-2/
    data yyfred(1)/1/,yyfred(2)/1/,yyfred(3)/1/
    data yyfred(4)/1/,yyfred(5)/1/,yyfred(6)/1/
    data yyfred(7)/2/,yyfred(8)/3/,yyfred(9)/4/
    data yyfred(10)/4/,yyfred(11)/5/,yyfred(12)/5/
    data yyfred(13)/6/,yyfred(14)/6/,yyfred(15)/7/
    data yyfred(16)/7/,yyfred(17)/7/,yyfred(18)/7/
    data yyfred(19)/8/,yyfred(20)/9/,yyfred(21)/10/
    data yyfred(22)/11/,yyfred(23)/12/
    data yyfred(24)/13/
    data yynset(1)/1/,yynset(2)/2/,yynset(3)/1/
    data yynset(4)/2/,yynset(5)/1/,yynset(6)/2/
    data yynset(7)/3/,yynset(8)/2/,yynset(9)/1/
    data yynset(10)/1/,yynset(11)/1/,yynset(12)/2/
    data yyprod(1)/11/,yyprod(2)/6/,yyprod(3)/7/
    data yyprod(4)/3/,yyprod(5)/12/,yyprod(6)/5/
    data yyprod(7)/1/,yyprod(8)/2/,yyprod(9)/10/
    data yyprod(10)/9/,yyprod(11)/8/,yyprod(12)/4/
    data yylhs(1)/267/,yylhs(2)/268/,yylhs(3)/268/,yylhs(4)/269/
    data yylhs(5)/269/,yylhs(6)/269/,yylhs(7)/270/,yylhs(8)/270/
    data yylhs(9)/271/,yylhs(10)/271/,yylhs(11)/271/,yylhs(12)/271/
    data yylen(1)/3/,yylen(2)/2/,yylen(3)/1/,yylen(4)/3/
    data yylen(5)/2/,yylen(6)/1/,yylen(7)/1/,yylen(8)/3/
    data yylen(9)/3/,yylen(10)/3/,yylen(11)/1/,yylen(12)/2/
    data yylset(1)/1/
    data yylset(2)/3/,yylset(3)/9/,yylset(4)/10/
    data yyls(1)/265/,yyls(2)/263/,yyls(3)/266/
    data yyls(4)/262/,yyls(5)/263/,yyls(6)/260/
    data yyls(7)/0/,yyls(8)/-1/,yyls(9)/0/

    yycover = NO				# reset error recovery flag
    status = OK					# assume success
    yyparse = OK				# assume success
    yycover = NO				# not in error recovery mode
    yysta = 1					# initial state
    yylexval = 0				# initial token value
    yytok = YYENDTOK				# initial token
    yystkp = 1					# initialize state stack pointer
    yysstk(yystkp) = 1				# initial state stack
    yyvstk(yystkp) = 0				# initial value stack

    while ( status != ERR )			# parse loop
	{# parse

	# Test for transition.
	state = yyfdtr( yysta, yytok, yyftrn, yytran, yyent )

	if ( state >= 0 )			# found transition
	    {# dotran
	    # call yydotran( state )		# do the transition
	    # Start of yydotran().
#
# The transition to state 'state' is performed by incrementing
# the stackpointer and stacking the token, it's value, and 'state'.
# Further parallel stacks may be maintained in this routine.
#
	    yystkp = yystkp + 1
	    if ( yystkp > YYMAXSTACK )		# test for stack ovflw
		dummy = yyperr( ovflerr, yyftrn,
		    yytran, yyent )		# call error routine
	    else
		{
		YYDUMPSTACKS			# stack dumping hook
		yytstk(yystkp) = yytok		# stack lookahead token
		yyvstk(yystkp) = yylexval	# stack it's value
		yysstk(yystkp) = state		# stack transition state
		yysta = state			# make it the current state
		}
	    # End of yydotran().

	    if ( state == yyfinal )		# transition to final state
		{
		retvalue = yyval
		return
		}
	    else				# more parsing to be done
		{
		if ( yycover == YES )		# trying to recover from erro
		    call yyrecover
		else
		    {
		    yytok = yylex( yylexval )	# call the lexical analyzer
		    YYTRACE			# yylex() error trace hook
		    }
		}

	    }# dotran
	else if ( state == YYERRTRAN )		# nonassociable association
	    {
	    yyparse = ERR
	    status = yyperr( nonasserr, yyftrn,
		yytran, yyent )			# try to recover from error
	    }
	else
	    {# dored
	    # Find reduction.
	    prodnum = yyfdrd( yysta, yytok, yyfred, yynset,
		yylset, yyprod, yyls )
	    if ( prodnum < 0 )			# no reduction
		{
		yyparse = ERR
		status = yyperr( illconerr, yyftrn,
		    yytran, yyent )		# try to recover from error
		}
	    else				# reduction found
		{
		YYDUMPSTACKS			# stack dumping hook
		# call yydored( prodnum )	# do the reduction
		# Start of yydored().
#
#  The reduction for production prodnum is performed by first finding
#  the new position for the stack pointer, by subtracting the length
#  of the production, found in the yylen vector for the production
#  number, from the stack pointer. The semantic routines are then
#  called into action by calling yysem with the production
#  number. The stacks are then adjusted
#  accordingly, a transition is made to the left hand side of
#  the production, found in vector yylhs, and the state on the top
#  of the stack. The current state is set to the state on the top
#  of the stack, the stack pointer is reset, and the routine returns.
#
		leptr = yystkp - yylen(prodnum) + 1 # get new stack pointer

		if ( leptr > YYMAXSTACK )	# check stack overflow
		    dummy = yyperr( ovflerr, yyftrn,
			yytran, yyent )		# call error routine
		else
		    {
		    yyval = yyvstk( leptr )	# default is '$1'
		    call yysem( prodnum )	# call semantics routine
		    yyvstk(leptr) = yyval	# put token value on stack
		    yytstk(leptr) = yylhs(prodnum) # put LHS token on stack
		    yysta = yyfdtr( yysstk(leptr - 1), yylhs(prodnum),
			yyftrn, yytran, yyent )
		    yysstk(leptr) = yysta	# put goto state on stack
		    yystkp = leptr		# reset stack pointer
		    }
		# End of yydored().

		if ( prodnum == 1 )		# start symbol reduced
		    {
		    retvalue = yyval
		    return
		    }
		}
	    }# dored

	}# parse

    retvalue = yyval
    return
end


### yyfdrd - find reduction corresponding to state stack
#
# SYNOPSIS
# --------
#   call yyfdrd( state, token )
#
#     state - current state
#     token - lookahead token
#
# DESCRIPTION
# -----------
#    If a reduction should be done when in state 'state' looking ahead at
#  symbol 'token', the production number is returned.  Otherwise, a -1 is
#  returned.  No reduction should be made if the token is a
#  non-terminal.  This is true because the parser makes all reductions
#  possible for a given token before it reads the next symbol.  If a
#  reduction were possible looking ahead to a non-terminal, then a
#  symbol must have been read before the reductions were finished on
#  this token, which will not happen.
#  The 'yyfred' vector gives for the state the first and last indices in the
#  'yynset' vector that must be scanned.  The 'yynset' vector gives the
#  lookahead set number.  If the bit for the token is set in the
#  lookahead set bit vector, then the production number found in vector
#  'yyprod' is returned.
#
integer function yyfdrd( state, token, yyfred, yynset, yylset, yyprod, yyls )
NOIMPLICIT
integer state, token, yyfred(ARB), yynset(ARB), yylset(ARB),
    yyprod(ARB), yyls(ARB)

    integer start				# first lookahead scan index
    integer iend				# last lookahead scan index
    integer jstart				# first lookahead bit index
    integer jend				# last lookahead bit index
    integer i, j

    start = yyfred(state)			# get first set index
    iend = yyfred(state + 1) - 1		# get last set index
    yyfdrd = -1

    if ( start <= iend )			# there is a lookahead set

    # Look through lookahead set for the symbol 'token'.

	for ( i = start; i <= iend ; i = i + 1 )
	    {
	    j = yynset(i)			# get lookahead set number
	    jstart = yylset(j)			# 1st lookahead bit index
	    jend = yylset(j + 1) - 1		# last lookahead bit indx

	    # Search for 'token' bit set.

	    for ( j = jstart; j <= jend; j = j + 1 )
		if ( yyls(j) == token )		# token found
		    {
		    yyfdrd = yyprod(i)		# return production number
		    return
		    }
	    }

	return

end


### yyfdtr - find next transition to do
#
# SYNOPSIS
# --------
#
#    newstate = yyfdtr( state, token )
#        state - current state
#        token - lookahead token
#        newstate - goto state of transition, or -1 if no legal transition
#
# DESCRIPTION
# -----------
#     This function decides whether a read transition should be
#  performed when in state 'state' looking at symbol 'token'. For the state
#  'state', you may transfer to the 'newstate' given in the yytran vector
#  if the entrance symbol for that transition is the same as the
#  symbol you want to read; 'token'. The yyftrn vector gives the beginning
#  and ending positions in the yytran vector for legal read
#  transitions in the state 'state'. If 'token' is not found in the
#  entrance symbols for legal read transitions for 'state', a
#  -1 is returned.
#
integer function yyfdtr( state, token, yyftrn, yytran, yyent )
NOIMPLICIT
integer state, token, yyftrn(ARB), yytran(ARB), yyent(ARB)

    integer start				# 1st index into state vector
    integer iend				# last index into state vector
    integer i, j

    yyfdtr = -1
    start = yyftrn(state)			# get first index
    iend = yyftrn(state + 1) - 1		# get last index

    if ( start <= iend )			# got some transitions

	# Read through transition set for lookahead symbol 'token'.

	for ( i = start; i <= iend; i = i + 1 )
	    {
	    j = yytran(i)			# possible trans state
	    if ( token == yyent( iabs(j) ) )	# see if token matches
		{
		if ( j < 0 )			# if non-associative
		    yyfdtr = YYERRTRAN		# return error
		else
		    yyfdtr = j			# else, return state
		return
		}
	    }

    return

end


### yyperr - error recovery routine
#
# SYNOPSIS
# --------
#    status = yyperr( errmsg )
#       errmsg - character array error message
#
# DESCRIPTION
# -----------
#    YYPERR attempts error recovery by popping states off the state stack,
# until a state is found from which it is legal to shift the ERROR token.
# If no such state is found, the parser returns ERR.
# If the state is found; the parser returns OK,
# the state is left on top of the stack, and the ERROR
# token is made the next lookahead token. The error recovery flag, yycover,
# is set and is not reset until 3 tokens have been successfully
# read and shifted. While this flag
# is set, any more errors found will only result in the lookahead
# token being discarded and a new one read in. This is done to hopefully
# not print a zillion error messages for one error.
#
integer function yyperr( msg, yyftrn, yytran, yyent )
NOIMPLICIT
character msg(MAXLINE)
integer yyftrn(ARB), yytran(ARB), yyent(ARB)

    YYSCOM					# parse state stacks
    YYPCOM					# parse global data
    integer state, i
    integer yylex				# returns next token
    integer yyfdtr				# finds transition on token

    yyperr = OK
    if ( yycover == YES )			# still in recovery mode
	{
	if ( yytok == YYENDTOK )		# couldn't recover from error
	    yyperr = ERR
	else
	    {
	    yytok = yylex( yylexval )		# just disregard current token
	    }
	}
    else
	{
	state = -1

	# Save curent token to be restored when error-token is shifted.
	yyetok = yytok
	yyeval = yylexval

	# Test each state to see if it contains a transition on ERROR.
	for ( i = yystkp; i > 0 & state < 0; i = i - 1 )
	    # Test for transition.
	    state = yyfdtr( yysstk(i), YYERROR, yyftrn, yytran, yyent )

	if ( state < 0 )			# didn't find recovery state
	    yyperr = ERR			# couldn't recover from error
	else
	    {
	    yycover = YES			# set error recovery flag
	    yyerct = 0				# initialize recovery count
	    yytok = YYERROR			# set lookahead to err token
	    yystkp = i + 1			# pop all other states off
	    yysta = yysstk(yystkp)		# reset current state
	    }

	YYERRACTION( msg )			# print error message
	}

    return

end


### yyrecover - try to recover from parse error
#
# YYrecover is called after an error has occurred, each time a
# shift is done.  The first shift will be the ERROR token, at
# which time the lookahead token (stored in yyetok) at the time
# of the error must be restored as the next lookahead token.
# After three tokens have been successfully read and shifted,
# the error recovery flag is reset.
#
subroutine yyrecover
NOIMPLICIT

    YYPCOM					# parse global data
    integer yylex


    if ( yyerct == 0 )				# error token just shifted
	{
	# Restore previous lookahead token.
	yytok = yyetok
	yylexval = yyeval
	}
    else
	{
	# Need next lookahead token from input.
	yytok = yylex( yylexval )

	if ( yyerct == 3 )			# 3 tokens succesfully shifted
	    yycover = NO			# reset recovery flag
	}

    yyerct = yyerct + 1

    return

end
